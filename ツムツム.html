<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ツムツム風ゲーム — 7キャラスキル版（修正版）</title>
<style>
  :root{ --ui-width:360px; }
  body{
    margin:0; font-family:"Segoe UI",system-ui,-apple-system,"Hiragino Kaku Gothic ProN","メイリオ",sans-serif;
    background: linear-gradient(#b7e7f4,#87dcec);
    display:flex; flex-direction:column; align-items:center; height:100vh; overflow:hidden;
  }
  #charSelect{ display:flex; gap:12px; margin-top:36px; flex-wrap:wrap; width:80%; justify-content:center; }
  .charBtn{ width:96px;height:96px;border-radius:12px;border:2px solid rgba(0,0,0,0.15); display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:700;font-size:14px;color:#fff;cursor:pointer; user-select:none; box-shadow:0 6px 14px rgba(0,0,0,0.12); }
  .charName{ font-size:12px; margin-top:6px; color:#fff; text-shadow:0 1px 0 rgba(0,0,0,0.2); }
  .c-mickey{ background:#f44336; } .c-donald{ background:#2196f3; } .c-goofy{ background:#4caf50; }
  .c-malef{ background:#9933ff; } .c-elsa{ background:#66b3ff; } .c-simba{ background:#ffb300; } .c-bay{ background:#eeeeee; color:#333; }

  #ui{ width:var(--ui-width); text-align:center; display:none; margin-top:10px; }
  #score,#combo,#time{ font-weight:800; font-size:16px; margin:6px 0; color:#212121; }
  #bars{ display:flex; flex-direction:column; align-items:center; gap:6px; }
  .barWrap{ width:300px; height:22px; background:#e6e6e6; border-radius:12px; overflow:hidden; }
  .bar{ height:100%; width:0%; transition:width .14s linear; }
  #skillBar{ background:#ff9800; }
  #feverBar{ background:#ffd54f; }

  #skillBtn{ margin-top:8px; padding:10px 18px; border-radius:12px; border:none; background:#1976d2; color:#fff; cursor:pointer; font-weight:800; }
  #skillBtn:disabled{ background:#999; cursor:not-allowed; }

  .ready-pulse{ animation: readyPulse 0.9s infinite; box-shadow:0 0 18px rgba(255,200,40,0.9),0 0 6px rgba(255,200,40,0.6) inset; transform:scale(1.02); }
  @keyframes readyPulse{ 0%{ transform:scale(1); }50%{ transform:scale(1.06); }100%{ transform:scale(1); } }

  canvas{ display:none; margin-top:8px; border-radius:14px; box-shadow:0 12px 30px rgba(0,0,0,0.16); background:#fff; touch-action:none; }

  #overlay{ position:fixed; inset:0; pointer-events:none; opacity:0; transition:opacity .18s; mix-blend-mode:screen; }
  .fever-ui{ filter: drop-shadow(0 0 12px rgba(255,200,40,0.9)); transform: scale(1.02); transition:transform .12s; }

  #resultScreen{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); }
  #resultBox{ width:320px; background:#fff; border-radius:16px; padding:18px; text-align:center; box-shadow:0 14px 36px rgba(0,0,0,0.3); }
  #resultBox h2{ margin:6px 0 10px; }
  #resultBox p{ margin:8px 0; font-weight:700; }
  #restartBtn{ margin-top:12px; padding:10px 16px; border-radius:12px; border:none; background:#4caf50; color:#fff; font-weight:700; cursor:pointer; }
  @media (max-width:420px){
    :root{ --ui-width:320px; }
    canvas{ width: calc(100vw - 24px); height:auto; }
  }
</style>
</head>
<body>

<!-- キャラ選択 -->
<div id="charSelect">
  <div class="charBtn c-mickey" data-char="mickey"><div>ミッキー</div><div class="charName">周囲小範囲除去</div></div>
  <div class="charBtn c-donald" data-char="donald"><div>ドナルド</div><div class="charName">コンボ維持2秒</div></div>
  <div class="charBtn c-goofy" data-char="goofy"><div>グーフィー</div><div class="charName">スコア2倍短時間</div></div>
  <div class="charBtn c-malef" data-char="maleficent"><div>マレフィセント</div><div class="charName">スキル：周囲巻き込み爆発</div></div>
  <div class="charBtn c-elsa" data-char="elsa"><div>エルサ</div><div class="charName">縦ライン除去</div></div>
  <div class="charBtn c-simba" data-char="simba"><div>シンバ</div><div class="charName">中央横範囲除去</div></div>
  <div class="charBtn c-bay" data-char="baymax"><div>ベイマックス</div><div class="charName">スキル：大ツム生成</div></div>
</div>

<!-- UI -->
<div id="ui">
  <div id="score">スコア: 0</div>
  <div id="combo">コンボ: 0</div>
  <div id="time">残り: 60秒</div>
  <div id="bars">
    <div class="barWrap"><div id="skillBar" class="bar"></div></div>
    <div class="barWrap"><div id="feverBar" class="bar"></div></div>
  </div>
  <button id="skillBtn" disabled>スキル発動</button>
  <button id="rebuildBtn" style="margin-top:8px; padding:10px 18px; border-radius:12px; border:none; background:#ff5722; color:#fff; cursor:pointer; font-weight:800;">
  ツム再構築
</button>
</div>

<canvas id="game" width="360" height="540"></canvas>
<div id="overlay"></div>

<!-- 結果 -->
<div id="resultScreen">
  <div id="resultBox">
    <h2>ゲーム終了！</h2>
    <p id="finalScore">スコア: 0</p>
    <p id="bestScore">ハイスコア: 0</p>
    <p id="bestCombo">最長コンボ: 0</p>
    <button id="restartBtn">もう一度遊ぶ</button>
  </div>
</div>

<!-- 音（外部URLなのでオフラインだと鳴らない可能性あり） -->
<audio id="bgm" loop src="https://freesound.org/data/previews/341/341695_6241250-lq.mp3"></audio>
<audio id="feverBgm" loop src="https://freesound.org/data/previews/331/331912_3248244-lq.mp3"></audio>
<audio id="popSound" src="https://freesound.org/data/previews/276/276020_5121236-lq.mp3"></audio>
<audio id="bombSound" src="https://freesound.org/data/previews/146/146725_2530050-lq.mp3"></audio>
<audio id="skillSound" src="https://freesound.org/data/previews/331/331912_3248244-lq.mp3"></audio>
<audio id="explosionSound" src="https://freesound.org/data/previews/235/235968_3981360-lq.mp3"></audio>

<script>
/* ===============================
   Settings & State
   =============================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");

const cols = 6, rows = 8, SIZE = 60;
const CHAR_DEFS = {
  mickey:   { color: "#f44336", name: "ミッキー" },
  donald:   { color: "#2196f3", name: "ドナルド" },
  goofy:    { color: "#4caf50", name: "グーフィー" },
  maleficent:{ color: "#9933ff", name: "マレフィセント" },
  elsa:     { color: "#66b3ff", name: "エルサ" },
  simba:    { color: "#ffb300", name: "シンバ" },
  baymax:   { color: "#e0e0e0", name: "ベイマックス" },
};
const COLORS = Object.values(CHAR_DEFS).map(c => c.color);

let tsums = []; // grid [r][c] = { color, x, y, targetY, isBomb, scale, bounced, type }
let selected = [];
let isDragging = false;

let score = 0, combo = 0, maxCombo = 0;
let skillGauge = 0;
let timeLeft = 60;
let fever = false;
let running = false;

let timerId = null, loopReq = null;
let selectedChar = null;

/* UI */
const scoreEl = document.getElementById("score");
const comboEl = document.getElementById("combo");
const timeEl = document.getElementById("time");
const skillBar = document.getElementById("skillBar");
const feverBar = document.getElementById("feverBar");
const skillBtn = document.getElementById("skillBtn");
const resultScreen = document.getElementById("resultScreen");
const finalScoreEl = document.getElementById("finalScore");
const bestScoreEl = document.getElementById("bestScore");
const bestComboEl = document.getElementById("bestCombo");
const restartBtn = document.getElementById("restartBtn");

/* Audio */
const bgm = document.getElementById("bgm");
const feverBgm = document.getElementById("feverBgm");
const popSound = document.getElementById("popSound");
const bombSound = document.getElementById("bombSound");
const skillSound = document.getElementById("skillSound");
const explosionSound = document.getElementById("explosionSound");

/* Popups */
let scorePopups = [];
let comboPopups = [];

/* Storage keys */
const HIGH_SCORE_KEY = "tsum_high_score_7c_fix";
const HIGH_COMBO_KEY = "tsum_high_combo_7c_fix";

/* ===============================
   Grid init & helper
   =============================== */
function newTsum(color, x, y, type="normal", isBomb=false){
  return { color, x, y, targetY: y, isBomb: !!isBomb, scale:1, bounced:false, pulsePhase: Math.random()*Math.PI*2, type };
}

function initGrid(){
  tsums = [];
  for(let r=0;r<rows;r++){
    tsums[r] = [];
    for(let c=0;c<cols;c++){
      const color = COLORS[Math.floor(Math.random()*COLORS.length)];
      tsums[r][c] = newTsum(color, c*SIZE, r*SIZE);
    }
  }
  canvas.width = cols * SIZE;
  canvas.height = rows * SIZE;
}

/* Character selection UI */
document.querySelectorAll(".charBtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    selectedChar = btn.dataset.char;
    document.getElementById("charSelect").style.display = "none";
    document.getElementById("ui").style.display = "block";
    canvas.style.display = "block";
    startGame();
  });
});

/* ===============================
   Start / End / Restart
   =============================== */
function startGame(){
  score = 0; combo = 0; maxCombo = 0; skillGauge = 0; timeLeft = 60; fever = false;
  scoreEl.textContent = "スコア: 0"; comboEl.textContent = "コンボ: 0"; timeEl.textContent = "残り: 60秒";
  skillBar.style.width = "0%"; feverBar.style.width = "0%"; skillBtn.disabled = true; skillBtn.classList.remove("ready-pulse");
  initGrid();
  running = true;
  try{ bgm.volume = 0.28; bgm.play(); } catch(e){}
  startTimer();
  loop();
}

function endGame(){
  running = false;
  if(timerId){ clearInterval(timerId); timerId = null; }
  if(loopReq) cancelAnimationFrame(loopReq);
  try{ bgm.pause(); bgm.currentTime = 0; feverBgm.pause(); feverBgm.currentTime = 0; } catch(e){}
  const best = parseInt(localStorage.getItem(HIGH_SCORE_KEY) || "0", 10);
  const bestComboStored = parseInt(localStorage.getItem(HIGH_COMBO_KEY) || "0", 10);
  if(score > best) localStorage.setItem(HIGH_SCORE_KEY, String(score));
  if(maxCombo > bestComboStored) localStorage.setItem(HIGH_COMBO_KEY, String(maxCombo));
  finalScoreEl.textContent = "スコア: " + score;
  bestScoreEl.textContent = "ハイスコア: " + (localStorage.getItem(HIGH_SCORE_KEY) || score);
  bestComboEl.textContent = "最長コンボ: " + (localStorage.getItem(HIGH_COMBO_KEY) || maxCombo);
  resultScreen.style.display = "flex";
}

restartBtn.addEventListener("click", ()=>{
  resultScreen.style.display = "none";
  document.getElementById("charSelect").style.display = "flex";
  document.getElementById("ui").style.display = "none";
  canvas.style.display = "none";
});

/* ===============================
   Timer
   =============================== */
function startTimer(){
  if(timerId) clearInterval(timerId);
  timerId = setInterval(()=>{
    if(!running){ clearInterval(timerId); return; }
    if(timeLeft > 0){
      timeLeft--;
      timeEl.textContent = "残り: " + timeLeft + "秒";
      if(timeLeft <= 0){
        clearInterval(timerId);
        endGame();
      }
    }
  }, 1000);
}

/* ===============================
   Input (pointer — mouse & touch)
   =============================== */
canvas.addEventListener("pointerdown", e => { if(!running) return; const p = getPos(e); startSelect(p); });
canvas.addEventListener("pointermove", e => { if(!running) return; if(isDragging){ const p = getPos(e); moveSelect(p); }});
canvas.addEventListener("pointerup", e => { if(!running) return; const p = getPos(e); endSelect(p); });

function getPos(e){
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

/* ===============================
   Selection logic (including diagonals)
   =============================== */
function findTsumAtPos(p){
  const c = Math.floor(p.x / SIZE);
  const r = Math.floor(p.y / SIZE);
  if(r >= 0 && r < rows && c >= 0 && c < cols) return { r, c, tsum: tsums[r][c] };
  return null;
}

function startSelect(p){
  const t = findTsumAtPos(p);
  if(!t || t.tsum.isBomb) return;
  isDragging = true;
  selected = [{ r: t.r, c: t.c }];
}

function moveSelect(p){
  const t = findTsumAtPos(p);
  if(!t) return;
  const last = selected[selected.length - 1];
  if(t.r === last.r && t.c === last.c) return;
  const lastT = tsums[last.r][last.c];
  const nowT = t.tsum;
  if(!nowT || nowT.isBomb) return;
  const dr = Math.abs(t.r - last.r), dc = Math.abs(t.c - last.c);
  if(nowT.color === lastT.color && dr <= 1 && dc <= 1){
    if(!selected.some(s => s.r === t.r && s.c === t.c)){
      selected.push({ r: t.r, c: t.c });
    }
  }
}

function endSelect(pos){
  isDragging = false;
  if(selected.length >= 3){
    popSelected();
    selected = [];
  } else {
    const t = findTsumAtPos(pos);
    if(t && t.tsum && t.tsum.isBomb){
      explodeBomb(t.r, t.c);
    }
    selected = [];
  }
}

/* ===============================
   popSelected (消去) + popups + combo/skill/fever logic
   - 改善点:
     ・スキル効果は activeSkill に集約（popSelected は消去の管理とスコア計算のみ）
     ・「big」ツムは3倍得点になるよう処理
   =============================== */
function popSelected(){
  if(selected.length === 0) return;

  // Determine which cells will be removed (exclude bomb kept if any)
  // Bomb creation logic (>=7) — pick one to become bomb (kept)
  let bombIdx = -1;
  if(selected.length >= 7){
    bombIdx = Math.floor(Math.random() * selected.length);
    const bp = selected[bombIdx];
    if(tsums[bp.r] && tsums[bp.r][bp.c]) tsums[bp.r][bp.c].isBomb = true;
  }

  // Collect removed cells info (types/colors) BEFORE nulling
  const removedInfos = [];
  for(let i=0;i<selected.length;i++){
    if(i === bombIdx) continue; // keep bomb cell
    const p = selected[i];
    const t = tsums[p.r] && tsums[p.r][p.c] ? tsums[p.r][p.c] : null;
    if(t){
      removedInfos.push({ r:p.r, c:p.c, color:t.color, type:t.type || "normal" });
    }
  }

  if(removedInfos.length === 0){
    // nothing removed (maybe only bomb placed)
    // still reset selection state and return
    clearTimeout(popSelected.comboTimer);
    popSelected.comboTimer = setTimeout(()=>{
      combo = 0; comboEl.textContent = "コンボ: 0";
    }, 2000);
    return;
  }

  // Calculate points per removed cell (respect 'big' type and temp multiplier)
  const feverMult = fever ? 1.5 : 1.0;
  let totalPoints = 0;
  for(const info of removedInfos){
    const base = 100;
    const bigMult = (info.type === "big") ? 3 : 1;
    const tmp = Math.floor(base * bigMult * (combo + 1) * feverMult * (tempMultiplier || 1.0));
    totalPoints += tmp;
  }

  // average pos for popup
  const avg = removedInfos.reduce((acc,p)=>{ acc.x += p.c * SIZE + SIZE/2; acc.y += p.r * SIZE + SIZE/2; return acc; }, {x:0,y:0});
  avg.x /= removedInfos.length; avg.y /= removedInfos.length;
  scorePopups.push({ x: avg.x, y: avg.y, text: "+" + totalPoints, alpha: 1, vy: -1.6 });

  try{ popSound.currentTime = 0; popSound.play(); } catch(e){}

  // apply removal in grid
  for(const info of removedInfos){
    tsums[info.r][info.c] = null;
  }

  // scoring & combo
  score += totalPoints;
  combo++;
  if(combo > maxCombo) maxCombo = combo;
  scoreEl.textContent = "スコア: " + score;
  comboEl.textContent = "コンボ: " + combo;
  comboPopups.push({ x: canvas.width/2, y: canvas.height/2 - 20, text: combo + " COMBO!!", alpha: 1, vy: -1.2 });

  // skill-gauge increases only for removals of the selectedChar color (unless fever)
  if(!fever){
    let gaugeIncrease = 0;
    for(const info of removedInfos){
      if(info.color === CHAR_DEFS[selectedChar].color) gaugeIncrease += 10;
    }
    skillGauge = Math.min(100, skillGauge + gaugeIncrease);
    skillBar.style.width = skillGauge + "%";
    if(skillGauge >= 100){
      skillBtn.disabled = false;
      skillBtn.classList.add("ready-pulse");
    }
  }

  // Apply gravity to fill holes
  applyGravity();

  // Reset combo timer
  clearTimeout(popSelected.comboTimer);
  popSelected.comboTimer = setTimeout(()=>{
    combo = 0;
    comboEl.textContent = "コンボ: 0";
  }, 2000);

  // char passive effects are intentionally minimal — big effects come from activeSkill
  // Fever check
  if(combo >= 10 && !fever) startFever();
}

/* ===============================
   temp score multiplier (for Goofy)
   =============================== */
let tempMultiplier = 1.0, tempMultTimer = null;
function startTemporaryScoreMultiplier(seconds, mult){
  tempMultiplier = mult;
  if(tempMultTimer) clearTimeout(tempMultTimer);
  tempMultTimer = setTimeout(()=> { tempMultiplier = 1.0; tempMultTimer = null; }, seconds*1000);
}

/* ===============================
   Bomb explosion
   =============================== */
function explodeBomb(r0,c0){
  try{ bombSound.currentTime = 0; bombSound.play(); } catch(e){}
  for(let r=r0-1;r<=r0+1;r++){
    for(let c=c0-1;c<=c0+1;c++){
      if(r>=0 && r<rows && c>=0 && c<cols) tsums[r][c] = null;
    }
  }
  // replace bomb cell with a new tsum above so it falls
  tsums[r0][c0] = newTsum(COLORS[Math.floor(Math.random()*COLORS.length)], c0*SIZE, -SIZE);
  applyGravity();
}

/* ===============================
   Gravity (落下) — with stable bounce prevention
   =============================== */
function applyGravity(){
  for(let c=0;c<cols;c++){
    const stack = [];
    for(let r=rows-1;r>=0;r--){
      if(tsums[r][c]) stack.push(tsums[r][c]);
    }
    for(let r=rows-1;r>=0;r--){
      if(stack.length > 0){
        const t = stack.shift();
        t.targetY = r * SIZE;
        // mark bounced false so it can bounce only when falling from distance
        t.bounced = false;
        tsums[r][c] = t;
      } else {
        const color = COLORS[Math.floor(Math.random()*COLORS.length)];
        const t = newTsum(color, c*SIZE, -SIZE);
        t.targetY = r * SIZE;
        tsums[r][c] = t;
      }
    }
  }
}

/* ===============================
   Skill button & active skills (character-specific)
   - clearTimeout(popSelected.comboTimer) to prevent combo loss on skill use
   =============================== */
skillBtn.addEventListener("click", ()=>{
  if(!running) return;
  if(skillGauge < 100 && !fever) return;
  // prevent combo from being lost when using skill
  clearTimeout(popSelected.comboTimer);

  if(!fever) skillGauge = 0;
  skillBar.style.width = "0%";
  skillBtn.disabled = true;
  skillBtn.classList.remove("ready-pulse");
  try{ skillSound.currentTime = 0; skillSound.play(); } catch(e){}

  activeSkill(selectedChar);
  applyGravity();
});
/* ===============================
   Rebuild button
   =============================== */
const rebuildBtn = document.getElementById("rebuildBtn");

rebuildBtn.addEventListener("click", ()=>{
  if(!running) return;
  initGrid();        // 新しいツムでグリッド再構築
  applyGravity();    // 上から落下させる
});

function activeSkill(char){
  if(char === "mickey"){
    // remove up to 5 random tsums
    let removed = 0;
    const attempts = 0;
    while(removed < 5){
      const r = Math.floor(Math.random()*rows);
      const c = Math.floor(Math.random()*cols);
      if(tsums[r][c]){
        tsums[r][c] = null;
        removed++;
      }
    }
    flashOverlay("rgba(255,200,200,0.6)", 320);
    try{ explosionSound.currentTime=0; explosionSound.play(); }catch(e){}
  } else if(char === "donald"){
    // grant extra combo window (don't reset combo for next 3 sec)
    clearTimeout(popSelected.comboTimer);
    popSelected.comboTimer = setTimeout(()=>{
      combo = 0;
      comboEl.textContent = "コンボ: 0";
    }, 3000);
    flashOverlay("rgba(180,210,255,0.45)", 300);
  } else if(char === "goofy"){
    // grant immediate score multiplier for 5s
    startTemporaryScoreMultiplier(5, 2.0);
    flashOverlay("rgba(200,255,200,0.45)", 300);
  } else if(char === "maleficent"){
    // MALeficent active: for a few random centers, remove 3x3 around them
    for(let i=0;i<4;i++){
      const r = Math.floor(Math.random()*rows);
      const c = Math.floor(Math.random()*cols);
      for(let rr=r-1;rr<=r+1;rr++){
        for(let cc=c-1;cc<=c+1;cc++){
          if(rr>=0 && rr<rows && cc>=0 && cc<cols) tsums[rr][cc] = null;
        }
      }
    }
    flashOverlay("rgba(170,100,255,0.55)", 380);
    try{ explosionSound.currentTime=0; explosionSound.play(); }catch(e){}
  } else if(char === "elsa"){
    // remove a random column
    const col = Math.floor(Math.random()*cols);
    for(let r=0;r<rows;r++) tsums[r][col] = null;
    flashOverlay("rgba(160,220,255,0.65)", 420);
    try{ explosionSound.currentTime=0; explosionSound.play(); }catch(e){}
  } else if(char === "simba"){
    // clear a wide horizontal band (center)
    const centerRow = Math.floor(rows/2);
    for(let rr=centerRow-2; rr<=centerRow+2; rr++){
      if(rr>=0 && rr<rows){
        for(let cc=0; cc<cols; cc++) tsums[rr][cc] = null;
      }
    }
    flashOverlay("rgba(255,210,120,0.45)", 420);
    try{ explosionSound.currentTime=0; explosionSound.play(); }catch(e){}
  } else if(char === "baymax"){
    // spawn two big tsums that count triple when popped:
    for(let i=0;i<2;i++){
      const rc = Math.floor(Math.random()*cols);
      // Insert a big tsum at top of column by shifting column down:
      // Build column stack
      const stack = [];
      for(let r=0;r<rows;r++){
        if(tsums[r][rc]) stack.push(tsums[r][rc]);
      }
      // create big
      const bigColor = COLORS[Math.floor(Math.random()*COLORS.length)];
      const big = newTsum(bigColor, rc*SIZE, -SIZE*1.2, "big");
      // new stack: big at front, then existing
      stack.unshift(big);
      // reassign column from top (r=0) downward using stack (any overflow will be trimmed)
      for(let r=0;r<rows;r++){
        const t = stack[r] ? stack[r] : null;
        if(t){
          t.targetY = r*SIZE;
          t.bounced = false;
          tsums[r][rc] = t;
        } else {
          const color = COLORS[Math.floor(Math.random()*COLORS.length)];
          tsums[r][rc] = newTsum(color, rc*SIZE, -SIZE);
          tsums[r][rc].targetY = r*SIZE;
        }
      }
    }
    flashOverlay("rgba(230,230,230,0.8)", 320);
    try{ skillSound.currentTime=0; skillSound.play(); }catch(e){}
  }
}

/* overlay flash helper */
function flashOverlay(color, dur){
  overlay.style.background = color;
  overlay.style.opacity = 1;
  setTimeout(()=> overlay.style.opacity = 0, dur);
}

/* ===============================
   Fever (visuals & audio)
   =============================== */
function startFever(){
  if(fever) return;
  fever = true;
  try{
    feverBgm.currentTime = 0; feverBgm.play();
    bgm.pause();
  } catch(e){}
  document.getElementById("ui").classList.add("fever-ui");
  overlay.style.background = "rgba(255,220,120,0.18)";
  overlay.style.opacity = 1;
  feverBar.style.width = "100%";
  let fTime = 10;
  const fInt = setInterval(()=>{
    if(!running){ clearInterval(fInt); return; }
    fTime--;
    feverBar.style.width = (fTime/10*100) + "%";
    if(fTime <= 0){
      clearInterval(fInt);
      endFever();
    }
  }, 1000);
}

function endFever(){
  fever = false;
  try{ feverBgm.pause(); feverBgm.currentTime = 0; bgm.volume = 0.28; bgm.play(); } catch(e){}
  document.getElementById("ui").classList.remove("fever-ui");
  overlay.style.opacity = 0;
  feverBar.style.width = "0%";
}

/* ===============================
   Popups update
   =============================== */
function updatePopups(){
  for(let i = scorePopups.length - 1; i >= 0; i--){
    const p = scorePopups[i];
    p.y += p.vy; p.vy += -0.02; p.alpha -= 0.03;
    if(p.alpha <= 0) scorePopups.splice(i,1);
  }
  for(let i = comboPopups.length - 1; i >= 0; i--){
    const p = comboPopups[i];
    p.y += p.vy; p.vy += -0.02; p.alpha -= 0.03;
    if(p.alpha <= 0) comboPopups.splice(i,1);
  }
}

/* ===============================
   Update loop: falling, bounce, bomb pulse, UI check
   =============================== */
let globalTime = 0;
function update(){
  globalTime += 0.016;
  const baseLerp = 0.20;
  const lerp = fever ? Math.min(0.36, baseLerp * 1.3) : baseLerp; // fever: ~1.3x

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const t = tsums[r][c];
      if(!t) continue;

      // smooth fall using t.y
      t.y += (t.targetY - t.y) * lerp;

      // bounce control: trigger only once when arriving, reset when moved away sufficiently
      if (!t.bounced && Math.abs(t.targetY - t.y) < 1) {
        t.bounced = true;
        t.scale = 1.18;
        t._bounceVy = -0.06;
      }
      if (t.scale && t.scale !== 1) {
        t.scale += t._bounceVy || 0;
        t._bounceVy = (t._bounceVy || 0) * 0.93;
        if (t.scale <= 1.0) {
          t.scale = 1.0;
          t._bounceVy = 0;
        }
      }
      if (Math.abs(t.targetY - t.y) > 3) {
        t.bounced = false;
      }

      // bomb pulse
      if(t.isBomb){
        t.pulsePhase += 0.12;
      }
    }
  }

  updatePopups();

  if(skillGauge >= 100){
    if(skillBtn.disabled) skillBtn.disabled = false;
    if(!skillBtn.classList.contains("ready-pulse")) skillBtn.classList.add("ready-pulse");
  } else {
    if(skillBtn.classList.contains("ready-pulse")) skillBtn.classList.remove("ready-pulse");
  }
}

/* ===============================
   Draw: grid, bombs, popups, combo stroke
   =============================== */
function draw(){
  // background (fever change)
  if(fever){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,"#fff7e0"); g.addColorStop(1,"#fff0c0");
    ctx.fillStyle = g;
  } else {
    ctx.fillStyle = "#ffffff";
  }
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // grid
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const t = tsums[r][c];
      if(!t) continue;
      const cx = t.x + SIZE/2;
      const cy = t.y + SIZE/2;
      const bombPulse = t.isBomb ? (1 + 0.06 * Math.sin(t.pulsePhase)) : 1.0;
      const drawScale = (t.scale || 1) * bombPulse;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(drawScale, drawScale);
      ctx.beginPath();
      // draw plain filled circle (no emoji)
      ctx.arc(0,0,SIZE/2.5,0,Math.PI*2);
      ctx.fillStyle = t.isBomb ? "#555" : t.color;
      ctx.fill();

      // draw bigger ring for "big" tsums
      if(t.type === "big"){
        ctx.lineWidth = 6;
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.stroke();
      }

      // selection highlight
      if(selected.some(s => s.r === r && s.c === c)){
        ctx.lineWidth = 5; ctx.strokeStyle = "#fff"; ctx.stroke();
      }
      ctx.restore();

      // bomb halo
      if(t.isBomb){
        const phase = 0.5 + 0.5 * Math.sin(t.pulsePhase);
        ctx.beginPath();
        ctx.arc(cx, cy, (SIZE/2.5) * (1.15 + 0.25 * phase), 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${0.08 + 0.12 * phase})`;
        ctx.lineWidth = 6;
        ctx.stroke();
      }
    }
  }

  // score popups (with stroke during fever)
  for(const p of scorePopups){
    ctx.globalAlpha = Math.max(0, p.alpha);
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "center";
    if(fever){
      ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeText(p.text, p.x, p.y);
      ctx.fillStyle = "#ffd54f";
    } else {
      ctx.fillStyle = "#fff";
    }
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha = 1;
  }

  // combo popups
  for(const p of comboPopups){
    ctx.globalAlpha = Math.max(0, p.alpha);
    ctx.font = "bold 28px sans-serif";
    ctx.textAlign = "center";
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#000";
    ctx.strokeText(p.text, p.x, p.y);
    ctx.fillStyle = fever ? "#ffb300" : "#ffea00";
    ctx.fillText(p.text, p.x, p.y);
    ctx.globalAlpha = 1;
  }
}

/* ===============================
   Main loop
   =============================== */
function loop(){
  if(!running) return;
  update();
  draw();
  loopReq = requestAnimationFrame(loop);
}

/* ===============================
   Utilities
   =============================== */
function selectedCharColor(){
  return CHAR_DEFS[selectedChar].color;
}

document.addEventListener("visibilitychange", ()=>{
  if(document.hidden){
    try{ bgm.pause(); feverBgm.pause(); } catch(e){}
  } else {
    if(running && !fever){ try{ bgm.play(); } catch(e){} }
  }
});
document.addEventListener('touchmove', (e)=>{ if(isDragging) e.preventDefault(); }, { passive:false });

/* initialize grid (wait for character selection to start actual game) */
initGrid();

</script>
</body>
</html>
